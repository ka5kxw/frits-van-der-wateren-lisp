**************LISP 1,5 *******************
*
*COPYRIGHT 1978 BY:
*
*FRITS VAN DER WATEREN
*VAN 'T HOFFSTRAAT 140
*2014 RK HAARLEM
*THE NETHERLANDS

*LISP STARTS AT $100.
*	AND AUTOMATICALLY ALLOCATES ALL CONTIGUOUS MEMORY
*	AND RESERVES 7/8 FOR CELL STORAGE (4 BYTES PER CE
*	AND 1/8 FOR STACK (2 BYTES PER WORD).
*
*RESTART IS AT $103
*	THE CURRENT OBLIST IS MAINTAINED BUT THEa
*	A-LIST BINDINGS ARE LOST.
*	FURTHERMORE A GARBAGE COLLECTION IS FORCED.
*
*THE DEVICE TABLE IS LOCATED AT $106
*	AND CAN BE EXTENDED BY TWO MORE DEVICES.
*	IMPLEMENTED HANDLERS ARE:
*	#1 TTY WITH AN ACIA AT $FF00
*	#2 READER WITH A PIA AT $FF10 (A)
*	#3 PUNCH WITH A PIA AT $FF12(B)

		ORG 0
NIL 	RMB 4 			ATOM NIL
FWAM 	RMB 2 			FIRST WORD OF CELL STORAGE
LWAM 	RMB 2 			LAST WORO OF CELL STORAGE
STACK 	RMB 2 			BOTTOM OF STACK
LIMIT 	RMB 2 			STACK-LIMIT REGISTER
OBLSTB 	RMB 2 			POINTER TO OBJECT-LIST.
N 	RMB 2
FREE 	RMB 2 			POINTER TO FREE LIST
CURCEL 	RMB 2 			POINTER To CURRENT CELL
ARG1 	RMB 2 			HOLDS ARGUMENT 1 DURING EVALUATD
ARG2 	RMB 2
ARG3 	RMB 2
PROGB 	RMB 2	 		BEGIN OF CURRENT FROG-LIST
RUNP 	RMB 2 			RUNNING POINTER ON FROG-LIST
OBLSTP 	RMB 2
OP 	RMB 2
AP 	RMB 2
NUM1 	RMB 2
NUM2 	RMB 2
SAVEX 	RMB 2
TEMPX 	RMB 2
MP 	RMB 2
PNAME 	RMB 2
STEPC 	RMB 1
SIGN 	RMB 1
CP 	RMB 2	 		POINTER TO CURRENT INPUT CHAR.
DELFLG 	RMB 1
DEVICE 	RMB 2 			POINTS To I/O HANDLER LINK ADDRE
CCOUNT 	RMB 1 			CHARACTER COUNT FDR OUTPUT.

M 		EQU 1 		MARKER
F 		EQU $80		FILL CHARACTER
FIRSTC 	EQU * 			REMAINDER IS INPUT-BUFFER
		ORG $100
LASTC 	EQU *-1

		JMP START 	COLD START
		JMP RSTART 	WARM START
*
* DEVICE TABLE
*
* EACH ENTRY CONSISTS OF FOUR POINTERS
* TO I/O HANDLERS.
* POINTER 1 IS INPUT HANDLER
* POINTER 2 IS OUTPUT HANDLER
* POINTER 3 IS OPEN OR INITIALISE
* POINTER 4 IS CLOSE
*
* DEVICE #1 IS THE SYSTEM DEVICE
*
*
DEVTBL 	FDB TTYIN,TTYOUT,TTYOPN,ABORT
	FDB RDRIN,DUMMY,RDROPN,TR
	FDB DUMMY,PUNOUT,PUNOPN,PUNCLS
	FDB 0,0,0,0 			#4 FOR EXTENTION.
	FDB 0,0,0,0 			#5 FOR EXTENTION.
	FDB 0				ZERO ENDS TRE TABLE 


START 	LDX #NAMNIL+M 			SET ATOM NIL AT $0000
	STX NIL
	LDX #PRPNIL
	STX NIL+2 
	LDX #OBLIST
	STX OBLSTB 			BEGIN 0F OBLIST
	LDX #LISPSP
	STX FWAM 			FIRST FREE CELL.
	LDAA #%10001011 
SEEK 	STAA 0,X 			ALLOCATE ALL 
	CMPA 0,X 			CONTIGUOUS MEMORY 
	BNE END 			RIGHT AFTER LISP.
	CLR 0,X 
	INX
	BRA SEEK
END 	TXS
	STS STACK
	LDAA STACK 			RESERVE STACK SPACE
	LDAB STACK+1
	SUBB FWAM+1
	SBCA FWAM
	LSRA
	RORB
	LSRA
	RORB
	LSRA
	RORB
	SUBB STACK+1
	SBCA STACK
	COMA
	STAA LWAM 			LWAM=(STACK/8-STACX)
	LDAB #$80
	STAB LWAM+1 			0N PAGE-BOUNDARY + 128
	INCA 				STACK-LIMIT ON PAGE BOUNDARY.
	STAA LIMIT 			128 BYTES FOR STACK OVERFLOW
	CLR LIMIT+1
RSTR 	LDX #OBL1
	STX ARG2
	LDX #OBLIST
	LDX 2,X
	LDX 2,X
	JSR RPLACA 			RESTORE OBLIST
RSTART 	LDS STACK
	LDX #N
CLRLOC 	CLR 0,X 			CLEAR (NIL) WORK SPACE.
	INX
	CPX #OBLSTP
	BNE CLRLOC
	LDX N
	STX ARG1
	JSR OPEN 			OPEN DEV #1
	LDX #HED 			PRINT: LISP 1.5 AND
	JSR PMESSG 				VERSION NUMBER.
*
*
*************************
* THE LISP INTERPRETER 	*
* 			*
*************************
*
*

LISP 	LDS STACK
	LDX N
	JSR TEREAD
	JSR TERPRI
	JSR READ 			READ ONE S-EXPRESSION FROM DEV #
	STX ARG1
	LDX N
	STX ARG2
	STX PROGB
	LDX ARG1
	JSR EVAL 			EVALUATE
	STX ARG1
	LDX N
	STX ARG2
	JSR PRINT 			AND PRINT RESULT 0N DEV #1
	BRA LISP
* GET A CELL FROM THE FREE LIST
* 0N EXIT X POINTS TO THIS CELL
CELL 	LDX FREE
	BEQ GCOL 			FREE LIST IS EMPTY
	STX CURCEL 			GET CELL
	LDX 2,X				ADVANCE POINTER TO NEXT
	STX FREE 			FREE CELL ON LIST
	LDX CURCEL
	CLR 2,X 			CLEAN UP THIS CELL!
	CLR 3,X
	RTS

* GARBAGE COLLECTOR.
*
GCOL 	LDX ARG1
	BSR MARKL 			MARK 3 CURRENT ARGS.
	LDX ARG2
	BSR MARKL
	LDX ARG3
	BSR MARKL
	LDX PROGB
	BSR MARKL 			MARK PROG
	LDX OBLSTB
	BSR MARKL 			MARK OBLIST
	TSX
	DEX
GCOL1	CPX STACK
	BEQ GCOL3
	JSR PUSHX 			MARK ALL ACTIVE LISTS
	LDAA 1,X 			ON THE STACK 
	LDAB 2,X
	SUBB OBLSTB+1 
	SBCA OBLSTB
	BMI GCOL2 			POINTS IN SYSTEM AREA.
	LDX 1,X
	BSR MARKL 
GCOL2 	JSR PULLX 
	INX
	INX
	BRA GCOL1
GCOL3	LDX N
	STX FREE
	LDX LWAM
SWEEP 	CPX OBLSTB 			NOW SWEEP ALL UNMARKED CELLS
	BEQ SWPDON 			ONTO THE FREE LIST. .,
	DEX
	DEX
	DEX
	DEX
	LDAA 3,X
	ASR 3,X 			UNMARK CELL
	ASL 3,X
	RORA 
	BCS SWEEP 
	LDAA FREE 			LINK AN UNMARKED CELL
	LDAB FREE+1 		TO THE FREE-LIST
	CLR 0,X				
	CLR 1,X 
	STAA 2,X
	STAB 3,X
	STX FREE
	BRA SWEEP
SWPDON 	LDX FREE 
	BEQ FULL 			NO FREE-LIST!
	JMP CELL
FULL 	LDX #FL.MS
SYSERR 	JSR PMESSG
	JMP RSTART 

*
* MARK ONE LIST
*
MARKL 	BEQ MARKEX 			EMPTY LIST
	CLRA
	PSHA 				SET BOTTOM OF WORKSTACK T0 NIL.
	PSHA
MARK1 	CPX #1				NUMERIC CELL?
	BEQ MRKNUM 			YES
	STX FREE
	LDAA FREE
	LDAB FREE+1
	SUBB OBLSTB+1
	SBCA OBLSTB 		NO; LIST IN SYSTEM AREA?
	BMI MARK2 			YES; UP ONE LEVEL
	RORB 				NO, ATOM CELL?
	BCS	MRKATM 			YES 
	LDAA 3,X 
	RORA 				CELL MARKED?
	BCS MARK2 			YES,UP ONE LEVEL
	INC 3,X 			NO,MARK CELL
	JSR PUSHX 
	LDX 0,X 			DOWN ONE LEVEL
	BRA MARK1
MRKNAM 	INC 3,X 			MARK PRINTNAME OF ATOM
	LDX 2,X
MRKATM 	DEX
	BNE MRKNAM
	BRA MARK2
MRKNUM 	JSR PULLX			MARK ONE NUMERIC CELL
	LDX 2,X 
	INC 2,X
MARK2 	JSR PULLX 			UP ONE LEVEL
	BEQ MARKEX 			TOP LEVEL SO EXIT.
	LDX 2,X
	DEX 				TAKE CARE OF MARK
	BEQ MARK2
	BRA MARK1 .
MARKEX 	RTS
*
* INPUT ONE CHAR FROM TTY
*
TTYIN 	LDAA ACIACS
	ASRA
	BCC TTYIN
	LDAA ACIADA
	ANDA #$7F
	RTS
*
*OUTPUT ONE CHAR. 0N TTY
*
TTYOUT 	LDAB ACIACS 
	ASRB
	ASRB
	BCC TTYOUT
	STAA ACIADA
	RTS
*
*OPEN TTY  (INITIALISE)
* 
TTYOPN 	LDAA #%1
	STAA ACIACS
	BRA TR
*
*ABORT IF CTRL/C (ETX) IS PRESSED
*
ABORT 	LDAA ACIACS 			IF CTRL/C IS PRESSED
	ASRA 					THEN ABORT EVALUATION.
	BCC TR
	LDAA ACIADA
	CMPA #3
	BNE TR
	JMP LISP
TR 	JMP TRUE
ACIACS 	EQU $FF00			default ff00; kennbox f400
ACIADA 	EQU $FF01			default ff01; kennbox f400
*
* INPUT ONE CHARACTER FROM HIGH SPEED READER.
*

RDRIN	LDAA RDRC
	BPL RDRIN
	LDAA RDR
	COMA
	ANDA #$7F
	BEQ RDRIN 				IGNORE NULLS
	CMPA #$7F
	BEQ RDRIN 				IGNORE RUBOUT
	CMPA #$A
	BEQ RDRIN 				IGNORE LF
DUMMY 	RTS
*
*OPEN READER (INITIALISE)
*
RDROPN 	CLR RDRC
	CLR RDR
	LDAA #%101110
	STAA RDRC
	LDAA RDR 				SET FLAG
	BRA TR
*
* OUTPUT ONE CHARACTER ON PUNCH.
*
PUNOUT	LDAB PUNC
	BPL PUNOUT
	STAA PUN
	RTS
*
* OPEN PUNCH (INITIALISE) AND PUNCH LEADER.
PUNOPN 	CLR PUNC
	CLR PUN
	LDAA #%101110
	STAA PUNC
*
* CLOSE PUNCH; PUNCH TRAILER.
*
PUNCLS 	LDAA #150 
	STAA STEPC
TRAIL 	CLRA
	BSR PUNOUT
	DEC STEPC
	BNE TRAIL
	BRA TR
RDR 	EQU $FF10			default ff10;kennbox f410
RDRC 	EQU $FF11			default ff11;kennbox f411
PUN 	EQU $FF12			default ff12;kennbox f412
PUNC 	EQU $FF13			default ff13;kennbox f413
*
* BUFFER ONE LINE FROM INPUT DEVICE
*
DELINE 	LDAA #'@ 
	JSR OUTCH1 			OUTPUT AN @ ON CTRL/X
	JSR CRLF 			AND IGNORE WHOLE LINE.
INPSTR 	LDAA #'*
	JSR OUTCH1 			OUTPUT A PROMPT.
	LDX #FIRSTC 		INIT BUFFER
	CLR 0,X
NEXTCF 	CLR DELFLG
NEXTC	STX CP
	JSR INCH 
	CMPA #$18 			CTRL/x (CAN)?
	BEQ DELINE
	CMPA #$8 			BACKSPACE?
	BEQ DEL
	CMPA #$7F 			DELETE?
	BEQ DEL
	STAA 1,X 			NO,STORE CHAR.
	TST DELFLG 			AT END OF DEL SEQUENCE?
	BEQ NORML 
	LDAA #‘] 			YES,CLOSE STRING OF
	BSR OUTCH1 			DELETED CHARACTERS.
NORML 	LDAA 1,X 
	BSR OUTCH1 			ECHO TYPED CHAR.
	CMPA #$D 			CR?
	BEQ CR
	CPX #LASTC 			NO,BUFFER FULL?
	BEQ NEXTCF 			YES
	INX
	BRA NEXTCF
CR	LDX #FIRSTC 		RESET BUFFER POINTER
	STX CP
	CLR CCOUNT
	BSR OUTCH1 			REFLECT CR and LF.
	LDAA #$A
	BSR OUTCH1
	BRA GETC
DEL 	CPX #FIRSTC
	BEQ NEXTC 			BUFFER UNDERFLOW!
	DEX
	CMPA #8
	BEQ SHWDEL+2 
	TST DELFLG 			TYPE DELETED CHARACTERS
	BNE SHWDEL 			ON 'DEL' ONLY.
	LDAA #'[
	STAA DELFLG
	BSR OUTCH1 
SHWDEL 	LDAA 1,X 
	BSR OUTCH1
	BRA NEXTC
*
* GET ONE CHAR. FROM INPUT BUFFER
*
GETC	LDX CP
	LDAA 0,X 			GET CHARACTER FROM INPUT BUFFER
	CMPA #$D			END OF LINE?
	BEQ INPSTR 			YES,GO READ NEXT LINE
	LDAA 1,X 			NO,GET NEXT CHAR.
	INX
	STX CP 
	CMPA #',			 MAKE A 'SPACE' OF THE
	BEQ SP 				FOLLOWING CHARACTERS:
	CMPA #9 			'COMMA' 'TAB' CARRIAGE HET.‘
	BEQ SP
	CMPA #$D
	BNE NOSP
SP 	LDAA #$20
NOSP	RTS
*
* OUTPUT ONE CHAR.
*
OUTCH 	INC CCOUNT
	CMPA #'  			SPACE?
	BNE OUTCH1
	LDAA CCOUNT 		YES,MORE THAN 55 CHAR. ON ALINE?
	CMPA #55
	BGT CRLF 			YES,OUTPUT A CR & LF.
	LDAA #' 			No
OUTCH1 	STX TEMPX
	LDX DEVICE
	LDX 2,X
	JSR 0,X
	LDX TEMPX
	RTS
*
* INPUT ONE CHARACTER
*
INCH 	STX TEMPX
	LDX DEVICE
	LDX 0,X
	JSR 0,X
	LDX TEMPX
	RTS
* 
* PRINT MESSAGE 0N DEV #1
*
PMESSG 	STX MP
	LDX N
	BSR ASSIGN 			ASSIGN DEV #l
	BSR CRLF
	LDX MP
PMESG1 	LDAA 0,X
	BSR OUTCH 			PRINT STRING
	TST 0,X
	INX
	BPL PMESG1
	RTS
*
* NEW LINE 
*
CRLF 	PSHA
	LDAA #$D			CARRIAGE RETURN
	BSR OUTCH 			& LINE FEED 0N TTY.
	LDAA #$A
	BSR OUTCH
	CLR CCOUNT
	PULA
	RTS
*
* PUSH X ONTO STACK
*
PUSHX	STX TEMPX
	TSX
	CPX LIMIT
	BMI STKOVF			STACK OVERFLOW!
	LDAB 1,X			SAVE RETURN ADDRESS
	PSHB
	LDAB 0,X
	PSHB
	LDAB TEMPX				PLACE X ONTO STACK
	STAB 0,X
	LDAB TEMPX+1
	STAB 1,X
	LDX TEMPX
	RTS
STKOVF	LDX #SO.MS
	JMP SYSERR
*
* PULL X FROM STACK
*
PULLX	TSX
	LDAB 2,X				GET X FROM STACK
	STAB TEMPX
	LDAB 3,X
	STAB TEMPX+1
	PULB
	STAB 2,X				REPLACE RETURN ADDRESS
	PULB
	STAB 3,X
	LDX TEMPX
	RTS
*
*ASSIGN DEV # TO INPUT- AND OUTPUT HANDLER -
*X MUST POINT TO AN NUMERIC ATOM.
*IF X IS NIL THEN ASSIGN DEV TO 1
ASSIGN 	LDAB #1
	STX SAVEX 				SAVE ATOM POINTER
	BEQ DEV1
	LDX 0,X
	DEX
	BNE ID.ER 				NON NUMERIC DEV. #
	LDX SAVEX
	LDX 2,X
	LDAA 0,X
	BNE ID.ER 				DEV. # > 256!
	LDAB 1,X
	BEQ ID.ER 				DEV. # = 0!
DEV1 	LDX #DEVTBL-8
NXTDEV 	LDAA #8 				OK SO FAR!
X8 	INX 					NOW LOOKUP DEV.TABLE
	DECA 
	BNE X8
	LDAA 0,X
	BEQ ID.ER				ZERO ENDS THE THE TABLE
	DECB
	BNE NXTDEV
	STX DEVICE 				SET LINK ADDRESS 
	LDX ARG1
	RTS
ID.ER 	LDX #ID.MS
	JMP FATAL
*
* GET ONE CHAR. BUT SKIP SPACES.
*
GETCS 	JSR GETC
	CMPA #'
	BEQ GETCS
	RTS
*
* PUT BACK ONE CHAR. IN INPUT BUFFER
*
PUTBAK 	LDX CP
	DEX
	STX CP
	RTS
* (READ DEV)
* READ ONE S-EXPRESSION FROM 'DEV'
*
READ 	BSR ASSIGN 
READE 	BSR GETCS
	CMPA #'(
	BEQ S.EXPR 				EXPRESSION BEGINS WITH:(
	CMPA #'.
	BEQ SN.ER
	CMPA #')
	BEQ SN.ER 				. AND ) ARE ILLEGAL Now
	BSR PUTBAK
	BRA READ1E 				ATOMIC EXPRESSION.
SN.ER 	LDX #SN.MS
FATAL 	JSR PMESSG
	JMP LISP

S.EXPR 	JSR GETCS
	CMPA #'.
	BEQ SN.ER 				DOT IS ILLEGAL NOW
RDLIST 	LDX N 					EXPRESSION IS A LIST STRUCTURE
	CMPA #')
	BEQ S.END
	CMPA #'.
	BEQ DOT 				DOT NOTATION
	BSR PUTBAK
	BSR READE 				READ NEXT FORM 
	JSR PUSHX
	BSR GETCS
	BSR RDLIST 				AND GO IN RDLIST AGAIN.
	STX ARG2
	JSR PULLX
	STX ARG1
	JSR CONS 				NOW CONS ALL FORMS TO A LIST
S.END 	RTS
DOT 	BSR READE 				READ LAST FORM
	STX ARG2
	BSR GETCS
	CMPA #') 				WHICH MUST BE CLOSED WITH: )
	BNE SN.ER
	LDX ARG2
	RTS
*
* (READCH DEV)
* READ ONE CHARACTER FROM 'DEV'
*
READCH 	JSR ASSIGN
	JSR GETC 				GET ONE CHAR.
	LDX CP
	STX PNAME
	JMP AATOM 				AND BUILD AN ATOM OF IT.
SN.ER1 	JMP SN.ER
*
* (READI DEV)
*  READ AN ATOM FROM 'DEV'.
*
READ1 	JSR ASSIGN 
READ1E 	JSR GETCS
	LDX CP
	STX PNAME 				'PNAME' POINTS To BEGIN OF ATOM
	CMPA #''
	BEQ SQUOTE
	CMPA #'" 				' AND " ARE SUPER-QUOTE CHAR.
	BEQ	SQUOTE
	DEX 
	STX CP
RDATOM 	JSR GETC 				FIND END OF ATOM
	CMPA #'( ,
	BEQ ENDATM
	CMPA #')
	BEQ ENDATM
	CMPA #'
	BEQ ENDATM
	CMPA #'.
	BNE RDATOM
ENDATM 	JSR PUTBAK 				IF FIRST CHAR. IS + OR -
	LDX PNAME 				OR D-9 THEN ATOM Is NUMERIC.
	DEX
	CPX CP 					ANY ATOM?
	BEQ SN.ER1 				NO
	INX
	CLRB
	LDAA 0,X
	CMPA #'+
	BEQ NATOM
	TAB
	CMPA #'-
	BEQ NATOM
	CLRB
	CMPA #‘0
	BLT AATOM
	CMPA #'9
	BGT AATOM
	DEX
*
* ATOM IS NUMERIC.
*
NATOM 	STAB SIGN
	CLRA
	CLRB
	STAB NUM1
	STAB NUM1+1
NXTDIG 	CPX CP 					END OF ATOM?
	BEQ BLDNMB
	INX
	LDAA 0,X 				NO,GET NEXT DIGIT
	CMPA #‘0 				AND CHECK IF D-9
	BLT IN.ER
	CMPA #'9
	BGT IN.ER
	ANDA #$F
	STAA NUM2
	LDAA NUM1				NOW SHIFT DIGIT INTO NUMBER
	LDAB NUM1+1 			JUST READ SO FAR.
	ASLB 
	ROLA
	ASLB 
	ROLA
	ADDB NUM1+1
	ADCA NUM1
	ASLB
	ROLA
	ADDB NUM2 
	ADCA #0 
	STAA NUM1 
	STAB NUM1+1
	BRA NXTDIG
BLDNMB 	TST SIGN
	BEQ POSN 
	JSR NEG 				NEG. NUMBER IS 2'S COMPL.
POSN 	JMP PUTIN
IN.ER 	LDX #IN.MS
	JMP FATAL
*
* ATOM IS SUPER QUOTED.
*
SQUOTE 	STAA SIGN 				SAVE QUOTE CHAR
	INX
	STX PNAME
	DEX
BQ 	INX 
	LDAA 0,X 				NOW READ ALL CHAR.
	STX CP 					BETWEEN THE QUOTES,
	CMPA #$D 				A CR ALSO DELIMITS THE DUOTING
	BEQ AATOM
	CMPA SIGN
	BNE BQ
	LDAA #' 				DELETE LAST QUOTE CHAR.
	STAA 0,X 				IN THE BUFFER.
	DEX
	STX CP
	INX
	CPX PNAME 				IS THERE A QUOTED STRING?
	BNE AATOM
	LDX N 					NO,RETURN NIL
	RTS
*
*ATOM IS ALPHA NUMERIC. 
*
AATOM	LDX #OBLIST 
	LDX 2,X 
	LDX 2,X 				GET VALUE OF OBLIST
	STX NUM1
	LDX 0,X
NXTOBJ  STX OBLSTP
	LDX 0,X 				GET ATOM FROM DBLIST
	LDX 0,X 				AND GET ITS PRINTNAME
	DEX
	STX OP
	LDX PNAME
	STX AP
NXT2C	LDX OP 
	BEQ NOMTCH 
	LDAA 0,X
	LDAB 1,X 				GET 2 CHAR. FROM ATOM 0N OBLIST
	LDX 2,X 
	STX OP
	LDX AP 
	CMPA 0,X 				AND COMPARE WITH 2 CHAR.
	BNE NOMTCH 				OF ATOM TN INPUT BUFFER
	CPX CP 
	BEQ MATCH 
	CMPB 1,X 
	BNE NOMTCH
	INX
	INX
	STX AP
	DEX
	CPX CP
	BNE NXT2C
	LDX OP
	BNE NOMTCH
	LDAB #F
MATCH   CMPB #F
	BNE NOMTCH
	LDX OBLSTP 				ATOM IS ON THE OBLIST
	LDX 0,X 				RETURN ITS POINTER As VALUE.
	RTS
NOMTCH	LDX OBLSTP					NO MATCH SO FAR
	LDX 2,X
	BNE	NXTOBJ

*
* ATOM NOT ON OBLIST
*
	STX ARG1
	STX ARG2
	JSR CONS				BUILD ATOM CELL
	STX	ARG3
	LDX CP
	INX
	STX AP
	LDAA PNAME+1
	EORA AP+1
	RORA
	BCC BLDATM				EVEN NUMBER OF CHAR
	JSR CONS
	STX ARG2				ODD NUMBER OF CHAR
	LDX	AP					SO ADD A FILL CHAR
	LDAB #F
	BRA ODD	
BLDATM	JSR CONS					NOW BUILD AN ATOM,
	STX ARG2				WITH 2 CHAR PER CELL
	LDX AP
	DEX
	LDAB 0,X
ODD	DEX
	LDAA 0,X
	STX AP
	LDX ARG2
	STAA 0,X
	STAB 1,X
	LDX ARG3
	JSR RPLACA				UPDATE ATOM-CELL
	INC	1,X				AND SET ATOM-MARK
	LDX AP
	CPX PNAME
	BNE BLDATM
	LDX ARG3				AND ADD IT ON TOP OF THE OBLIST
	STX ARG1
	LDX NUM1
	LDX 0,X
	STX ARG2
	JSR CONS
	STX ARG2
	LDX NUM1
	JSR RPLACA				UPDATE OBLIST!
	LDX ARG3				VALUE IS THE NEW ATOM
	RTS
*
* (OPEN DEV FILENAME)
*
* OPEN A FILE ON 'DEV' WITH 'FILENAME'.
* ON NON FILE ORIENTED DEVICES,
* THIS CALL ONLY INITIALISES THE HANDLER
*
OPEN 	JSR ASSIGN
	LDX DEVICE 				GET OPEN-LINK FOR 'DEV'
	LDX 4,X
	JMP 0,X 				AND Go To REQUESTED HANDLER
*
* (CLOSE DEV)
*
* CLOSE FILE ON 'DEV'
*
CLOSE 	JSR ASSIGN
	LDX DEVICE
	LDX 6,X
	JMP 0,X
*
* (PRINT X DEV)
*
PRINT 	LDX ARG2
	JSR ASSIGN
PRINTE 	CLRA
	PSHA 					BOTTOM OF STACK IS NIL.
	PSHA
PRINT2 	STX ARG1
	JSR ATOM 				ATOMIC?
	BEQ PRINT7 				NO
	LDX ARG1
	BSR PRINTE 				YES,PRINT ATOM
PRINT3	JSR PULLX
	BNE PRINT4
	RTS
PRINT4	LDX 2,X					GET CAR-PART
	STX ARG1
	BEQ PRINT5 
	JSR ATOM 				CDR PART ATOMIC?
	BEQ PRINT6 				NO
	LDAA #'
	JSR OUTCH 
	LDAA #'.
	JSR OUTCH 				YES,PRINT A DOT ,
	LDAA #‘
	JSR OUTCH
	LDX ARG1
	BSR PRINTE 				AND PRINT ATOM
PRINT5 	LDAA #")
	JSR OUTCH
	BRA PRINT3
PRINT6 	LDAA #‘
	FCB $8C 				SKIP
PRINT7 	LDAA #'(
	JSR OUTCH
	LDX ARG1
	JSR PUSHX
	LDX 0,X
	BRA PRINT2
*
* (PRIN1 X DEV)
* PRINT 'PRINTNAME' 0F ATOM X
* 0R NUMERIC VALUE IN CASE OF A NUMBER
*
PRIN1 	LDX ARG2
	JSR ASSIGN
PRIN1E	JSR ABORT
	LDX ARG1
	LDAA 1,X
	RORA
	BCC NA.ER				NOT ATOMIC
	LDX 0,X					GET LINK TO PRINT NAME
	DEX						CLEAR ATOM ARRAY
	BEQ PRNMB				NUMERIC!
PRCHAR	LDAA 0,X				PRINT CHAR STRING UNTIL
	JSR OUTCH				FILLCHAR OR NIL
	LDAA 1,X
	BMI DONE
	JSR OUTCH
DONE	LDX 2,X
	BNE PRCHAR
	RTS						VALUE OF PRIN1 IS NIL
*
* ATOM IS NUMERIC
*
PRNMB 	LDX ARG1
	LDX 2,X					GET NUMBER
	LDAB 1,X
	LDAA 0,X
	BPL POS
	LDAA #'- 				NEGATIVE NUMBER,
	JSR OUTCH 				PRINT MINUS SIGN
	LDAA 0,X
	LDAB 1,X
	JSR NEG 				AND NEGATE NUMBER ’
POS 	LDX #DECTBL
	CLR AP
DEC1 	CLR SIGN 				BINARY TO DEC CONVERSION.
DEC2	INC SIGN 				WITH LEADING ZERO SUPPRESSION.
	SUBB 1,X
	SBCA 0,X
	BPL DEC2
	ADDB 1,X
	ADCA 0,X
	PSHA
	PSHB 
	LDAA SIGN 
	DECA
	BNE DEC3
	TST AP 
	BEQ DEC4 				LEADING ZERO
DEC3 	ADDA #'0 				MAKE ASCII
	STAA AP
	JSR OUTCH 				AND PRINT
DEC4 	INX
	INX
	PULB
	PULA
	TST 1,X 				AT END OF TABEL?
	BNE DEC1
	TBA
	ADDA #'0				YES,PRINT LAST DIGIT.
	JSR OUTCH
	BRA FALSE
DECTBL 	FDB 10000,1000,100,10,0
NA.ER 	LDX #NA.MS
PNTARG 	JSR PMESSG
	LDX ARG1
	JSR PRINTE 				PRINT ARGUMENT 
	BRA TERPRI
* (ATOM X)
* IF x IS ATOMIC THEN TRUE ELSE NIL
*
ATOM 	LDAA 1,X
	RORA
	BCS TRUE 				CELL Is ATOMIC
FALSE 	LDX N
		RTS
*
*(NUMBER X)
*
* IF x Is A NUMBER, VALUE Is TRUE; ELSE NIL.
NUMBER 	LDX 0,X
	DEX
*
* (NULL X)
*
* IF x IS NIL RETURN 'T';ELSE NIL.
*
NULL 	CPX N
	BNE FALSE
TRUE 	LDX #T
	RTS
*
* (TERPRI DEV)
*
* TERMINATES PRINTLINE (CR & LF)
* VALUE IS NIL
*
TERPRI 	JSR ASSIGN
	JSR CRLF
	BRA FALSE
*
* (TEREAD)
* RESET INPUT BUFFER
*
TEREAD 	LDX #FIRSTC
	STX CP
	LDAA #$D
	STAA 0,X
	BRA FALSE
*
* (EQ X Y)
*
* IF X IS EQUAL TO Y THE VALUE IS 'T',OTHERWISE NIL
*
EQ	CPX ARG2
	BEQ TRUE
	LDX 0,X
	DEX
	BNE FALSE
	LDX ARG2 
	LDX 0,X
	DEX
	BNE FALSE 
	LDX ARG1 
	JSR GET2N 			IF BOTH ARGUMENTS ARE NUMERIC
	SUBB 1,X 			THEN COMPARE THEIR VALUES
	BNE FALSE 
	SBCA 0,X
	BNE FALSE 
	BRA TRUE 
*
* (QUOTE )0
*
* PREVENT x FROM EVALUATION.
* VALUE Is x.
*
QUOTE 	LDX ARG1
	BEQ NO.ARG
	LDX 0,X
NO.ARG 	RTS
*
* (GREATER? X Y)
*
* IF X >= Y THEN TRUE ELSE FALSE
*
*
GREATR 	JSR GET2N 			GET 2 VALUES
	CMPA 0,x
	BLT FALSE
	BGT TRUE 
	CMPB 1,X
	BHI TRUE
	BRA FALSE
*
*(FUNCTION X )
*
* RETURNS THE LIST:
* (FUNARG X ALIST)
*
FUNCTI 	STX ARG3
	LDX ARG2
	STX ARG1
	LDX N
	STX ARG2
	BSR CONS 				(CONS ALIST NIL)
	STX ARG2
	LDX ARG3
	LDX 0,X
	STX ARG1
	BSR CONS 				(CONS x (CONS ALIST NIL)
	STX ARG2
	LDX #FUNARG
	STX ARG1
	BRA CONS 				(CONS FUNARG(CONS X(CONS ALIST)))
*
* (ALIST) 
*
* RETURNS THE CURRENT ASSOCIATION LIST AS VALUE.
*
ALIST 	LDX ARG2
		RTS
* 
* (CAR)
*
CAR 	LDAA 1,X
	LSRA
	BCS AA.ER 				CAR OF AN ATOM IS ILLEGAL.
	LDX 0,X
	RTS
AA.ER 	LDX #AA.MS
	JMP PNTARG
*
* (CDR X)
*
CDR 	LDX 2,x
	RTS
*
* (CONS X Y)
*
* VALUE IS A LIST OF wHICH THE CAR-PART IS x
* AND THE CDR-PART IS Y
* .
CONS 	JSR CELL 				GET A NEw CELL
	LDAA ARG1
	LDAB ARG1+1 
	STAA 0,X 				ARG1 TO CAR-PART
	STAB 1,X
*
* (RPLACD x Y) '
*
* REPLACE CDR-LINK OF x BY Y
*
RPLACD 	LDAA ARG2
	LDAB ARG2+1
	STAA 2,X
	STAB 3,X
	RTS
*
*(RPLACA X Y)
*
* REPLACE CAR-LINK OF X BY Y
*
RPLACA 	LDAA ARG2
	LDAB ARG2+1
	STAA 0,X
	STAB 1,X
	RTS
*
* (SETQ X Y)
*
* X GETS A VALUE, THE VALUE 0F Y
* VALUE OF SETQ IS THIS VALUE!
*
SETQ 	JSR PUSHX
	BEQ ARGO
	LDX 2,X
	BEQ ARGO
	LDX 0,X 				GET Y.
	STX ARG1
	LDX ARG2
	JSR PUSHX 				PUSH A-LIST
	LDX ARG1
	JSR EVAL 				EVALUATE Y
	STX ARG3
	JSR PULLX 				PULL UP A-LIST
	STX	ARG2
	JSR PULLX 				PULL UP ARG-LIST.
	LDX 0,X 				GET X
	STX ARG1
	JSR SASSOC 				0N A-LIST?
	BEQ SETAPV 				NO.
	STX ARG1 				YES,REPLACE
	LDX ARG3 				ASSOCIATED VALUE BY Y.
	STX ARG2
	LDX ARG1
	JSR RPLACD
	LDX 2,X 				RETURN WITH Y.
	RTS
SETAPV 	LDX ARG3 				NOT ON A-LIST; SO PUT THE
	STX ARG2 				VALUE,UNDER A11 APVAL IND.,
	LDX #APVAL 				ON ATOM' PROP-LIST.
	STX ARG3 				THIS IS DONE BY PUTPROP.
	BRA PUTPRP
ARGO 	LDX #TLA.MS
	JMP FATAL
* 
* (PUTPROP ATOM PROPERTY INDICATOR)
*
* PUT 'PROPERTY' ON PROPERTY-LIST OF 'ATOM'
* TOGETHER WITH 'INDICATOR'.
*
GETIND 	LDX ARG1 				GET NEXT IND. ON
	LDX 2,X PROPERTY LIST
	LDX 2,X
	STX ARG1
PUTPRP 	LDX ARG1
	LDX 2,X
	BEQ NO.PRP 				PROPERTY-LIST EXHAUSTED
	LDX 0,X 				GET INDICATOR.
	CPX ARG3 				IS IT THE REQUESTED IND?
	BNE GETIND 				N0!
	LDX ARG1 				YES,REPLACE PROP. ASSOCIATED
	LDX 2,X 				WITH THIS INDICATOR.
	LDX 2,X
	JSR RPLACA
	LDX 0,X 				AND RETURN WITH PROPERTY. 
	RTS
NO.PRP 	LDX ARG1 				NO SUCH INDICATOR 
	JSR PUSHX 				ON PROPERTY-LIST
	LDX ARG2
	STX ARG1
	LDX N 					NOW APPEND THE NEW PROP.
	STX ARG2 				TOGETHER WITH THE IND.
	JSR CONS 				TO THE PROPERTY-LIST.
	STX ARG2
	LDX ARG3
	STX ARG1
	JSR CONS
	STX ARG2
	JSR PULLX
	JSR RPLACD
	LDX 2,X
	LDX 2,X
	LDX 0,X 				RETURN WITH PROP.
	RTS 

*
* (COND (X Y)(P Q).....)
*
* IF X THEN Y ELSE IF P THEN Q ...... ELSE NIL
*
CONDI 	JSR PUSHX 				SAVE RUNNING POINTER 0N
	LDX 0,X 				LIST OF CONDITIONALS.
	LDX 0,X 				GET CONDITION
	STX ARG1
	LDX ARG2
	JSR PUSHX 				SAVE CURRENT A-LIST.
	LDX ARG1
	JSR EVAL 				AND EVALUATE
	STX ARG1
	BEQ NXTCND 				FALSE! SO NEXT CONDITION.
	JSR PULLX 				TRUE!
	STX ARG2 				RETRIEVE A-LIST AND RUNNING POI
	JSR PULLX
	LDX 0,X
	LDX 2,X 				AND GET ASSOCIATED EXPRESSION
	BEQ RETCND 				IF THERE IS ANY;
	LDX 0,X
	STX ARG1 				AND EVALUATE.
	JMP EVAL 				THE VALUE OF 'COND' IS THAT RESW
NXTCND 	JSR PULLX
	STX ARG2
	JSR PULLX
	LDX 2,X 				GET NEXT CONDITION
COND 	STX ARG1
	BNE CONDI
	RTS 					RUNNING OUT OF LIST;RESULT IS N11
RETCND 	LDX ARG1 				NO ASSOCIATED EXPRESSION,
	RTS 					SO RETURN VALUE OF CONDITION.
*
* (GET ATOM IND) ,,
*
* SEARCH ON ATOMS PROPERTY LIST FOR
* AN INDICATOR 'IND'.
* NHEN FOUND RETURN THE VALUE,
* ASSOCIATED WITH THIS INDICATOR;
* OTHERVISE RETURN NIL.
GET 	LDX 2,X 				(CDR ATOM) 
	STX ARG1
	BNE GET2
	RTS 					EMPTY PROPERTY,RETURN NIL
GET2 	LDX 0,X 				GET INDICATOR
	CPX ARG2 				MATCH?
	BEQ GET3
	LDX ARG1 				NO,NEXT INDICATOR!
	LDX 2,X
	BRA GET
GET3 	LDX ARG1 				YES,GET VALUE!
	LDX 2,X
	LDX 0,X
	RTS
* 
* (SASSOC VAR ALIST) 
*
* SEARCH FOR A VARABLE 'VAR' ON THE ,
* ASSOCIATION LIST 'ALIST'.
* WHEN FOUND,RETURN THE VARIABLE-VALUE PAIR;
* OTHERWISE RETURN NIL.
*
SASSOC 	LDX ARG2 				GET ALIST
	BRA ASSOCI
LOOKUP 	LDX 0,X 				(CAAR ALIST)
	LDX 0,X
	CPX ARG1 				MATCH?
	BEQ ONALST
	LDX SAVEX 				NO,GET NEXT PAIR!
	LDX 2,X
ASSOCI 	STX SAVEX 				EMPTY?
	BNE LOOKUP 				NO
	RTS 					YES,RETURN NIL
ONALST 	LDX SAVEX 				FOUND,RETURN VARIABLE
	LDX 0,X 				VALUE PAIR.
	RTS
*
* ILLEGAL FUNCTION NAME.
*
FN.ER	LDX #FN.MS
	JMP FATAL1
*
* NO IND. ON FUNCTION NAME PROPERTY.
NO.IND 	LDX ARG1
	LDX 2,X
	JSR PUSHX
	LDX ARG1
	LDX 2,X
	STX ARG1
	BSR SASSOC				LOOKUP THE A-LIST
	BEQ FN.ER 				FOR THIS FUNCTION NAME
	LDX 2,X 				AND TRY AGAIN.
	STX ARG1
	LDX ARG2
	STX ARG3
	JSR PULLX
	STX ARG2
	JSR CONS
	STX ARG1
	LDX ARG3
	STX ARG2
	LDX ARG1
*
* (EVAL FORM ALIST)
*
* EVALUATE FORM
*
EVAL 	STX ARG1
	JSR ABORT
	LDX ARG1
	JSR NUMBER				A NUMBER IS ITSELF A VALUE
	BEQ EVAL1
	LDX	ARG1
	RTS
EVAL1	LDX ARG1
	JSR ATOM				ATOMIC FORM?
	BEQ SPEC				NO, SPECIAL FORM
	JSR SASSOC				YES, ON A-LIST?
	BEQ EVAL3
	LDX 2,X				YES GET ITS ASSOCIATED VAL
EVALEX	RTS						AND RETURN WITH IT
EVAL3	LDX	#APVAL				NO, LOOKUP ATOMS PROPERTY-LIST
	STX ARG2				FOR AN APVAL-INDICATOR
	LDX	ARG1				AND RETURN WITH THAT VALUE.
	JMP GET
SPEC	LDX ARG1
	LDX 0,X
	JSR ATOM				ATOMIC FUNCTION NAME?
	BEQ EVAL4				NO
	LDX ARG1
	LDX 0,X
	JSR NUMBER				YES, IS IT A NUMBER?
	BNE FN.ER				YES, ILLEGAL FUNCTION
	LDX ARG1
	LDX 0,X
EVAL6	LDX 2,X					NO, GET PROPERTY
	STX SAVEX
	BEQ NO.IND				NIL!
	LDX	0,X					GET INDICATOR
	CPX	#FEXPR
	BEQ EXFEX				FEXPR
	CPX #EXPR
	BEQ EXEX				EXPR
	CPX #FSUBR		
	BEQ EXFSBR				FSBR
	CPX #SUBR
	BEQ EXSBR				SUBR
	LDX	SAVEX				NO SUCH INDICATOR FOUND YET,
	LDS 2,X					GET NEX IND. FROM PROPERTY!
	BRA EVAL6
EVAL4	LDX	ARG1				GO EVALUATE ARG. LIST
	BRA	EVAL9				AND HAND OVER TO APPLY
EXFEX   LDX SAVEX
	JSR PUSHX
	LDX ARG1
	JSR PUSHX
	LDX ARG2				BUILD A LIST OF TWO ELEMENTS
	STX ARG3				THE FIRST IS THE ARG-LIST
	STX ARG1				THE SECOND IS THE A-LIST
	LDX	N
	STX ARG2
	JSR CONS
	STX ARG2
	JSR PULLX
	LDX 2,X
	STX ARG1
	JSR CONS
	STX ARG2
	JSR PULLX
	LDX 2,X
	LDX 0,X					GET FUNCTION AND GO TO APPLY
	BRA GO.PLY
EXEX	LDX SAVEX
	LDX 2,X
EVAL9	LDX 0,X
	JSR PUSHX				PUSH FUNCTION
	LDX ARG2
	JSR PUSHX				PUSH CURRENT A-LIST
	LDX ARG1
	LDX 2,X					GET ARGUMENT LIST
	STX ARG1
	JSR EVLIS				AND EVALUATE!
	STX ARG2
	JSR PULLX				PULL UP A-LIST
	STX ARG3
	JSR PULLX				PULL UP FUNCTION
GO.PLY	STX ARG1				AND GO INTO APPLY
	BRA	APPLY
EXFSBR  LDX SAVEX 
	LDX 2,X 				GET MACHINE ENTRY ADDRESS.
	LDX 0,X
	JSR PUSHX 				PUSH FOR TRICKY JUMP
	LDX ARG1 				GET ARGUMENT1 FOR FUNCTION
	LDX 2,X
	STX ARG1 				ARG2 = A-LIST
	RTS 					GOTO MACHINE ROUTINE
EXSBR 	LDX SAVEX
	LDX 2,X 				GET MACHINE ENTRY ADDRESS.
	LDX 0,X
	JSR PUSHX 				AND PUSH FOR TRICKY JUMP
	LDX ARG1
	LDX 2,X
	STX ARG1
	JSR EVLIS				EVALUATE ARGUMENT.
ARGLST	STX CURCEL				SAVE RESULT
	LDAA #6
	LDX #ARG1
	STX SAVEX
CLRARG	CLR 0,X					'NIL' ALL ARGUMENTS
	INX
	DECA
	BNE CLRARG
GETARG	LDX CURCEL
	BEQ GSUBR				END OF ARG. LIST
	LDAA 0,X
	LDAB 1,X
	LDX 2,X
	STX CURCEL
	LDX SAVEX
	CPX #ARG3+2
	BEQ TMA.ER
	STAA 0,X
	STAB 1,X
	INX
	INX
	STX SAVEX
	BRA GETARG
TMA.ER	LDX #TMA.MS				TOO MANY ARGUMENTS!
	JSR PMESSG
	JSR CRLF
GSUBR	LDX ARG1				X=ARG1 ON ENTRY
EX	RTS						AND GOTO MACHINE SUBR.
*
* (APPLY FN ARGS ALIST)
*
* APPLY THE ARGUMENT TO 'FN'
*
APPLY 	BEQ EX 					NIL AS FUNCTION RETURNS NIL!
	JSR ATOM 				ATOMIC FUNCTION-NAME?
	BEQ APPLY				NO
	LDX ARG1
	JSR NUMBER 				YES,IS IT A NUMBER?
	BNE FN.ER. 				YES,ILLEGAL FUNCTION.
	LDX ARG1 				NO,GET ITS PROPERTY.
APPLY3 	LDX 2,X
	BEQ APPLY2 				ILLEGAL FUNCTION NAME
	STX SAVEX
	LDX 0,X 				GET INDICATOR!
	CPX #SUBR
	BEQ EXSBR1 				SUBR.
	CPX #EXPR
	BEQ EXEX1 				EXPR.
	LDX SAVEX
	LDX 2,X 				NONE OF THESE,GET NEXT IND.
	BRA APPLY3
APPLY2 	LDX ARG2 				NOW TRY TO FIND
	JSR PUSHX 				FUNCTION-NAME ON A-LIST
	LDX ARG3
	STX ARG2
	LDX ARG1
	JSR SASSOC
	BEQ FN.ER. 				NOT THERE,SO ERROR
	LDX 2,X 				FOUND!,GET ASSOCIATED NAME
	STX ARG1
	JSR PULLX 				AND TRY AGAIN
	STX ARG2
	LDX ARG1
	BRA APPLY
FN.ER. 	JMP FN.ER
EXSBR1 	LDX SAVEX
	LDX 2,X 				GET MACHINE ENTRY-ADDRESS
	LDX 0,X
	JSR PUSHX 				AND PUSH FOR TRICKY JUMP!
	LDX ARG2 				GET ARGUMENT LIST
	JMP ARGLST 				AND GO EVALUATE FIRST
EXEX1 	LDX SAVEX 				EXPR INDICATOR
	LDX 2,X 				GET FUNCTION LIST
	LDX 0,X
	STX ARG1
	BRA APPLY 				AND GO INTO APPLY AGAIN
APPLY1 	LDX ARG1
	LDX 0,X 				FUNCTION IS A LIST. 
	CPX #LAMBDA
	BEQ EVLAMB 				LAMBDA FORM!
	CPX #FUNARG
	BEQ EVLFNA 				FUNARG FORM!
	LDX ARG2
	JSR PUSHX		 		NONE OF THESE;
	LDX ARG3 				SO EVALUATE FUNCTION LIST FIRST
	STX ARG2
	JSR PUSHX
	LDX ARG1
	JSR EVAL
	STX ARG1
	JSR PULLX
	STX ARG3
	JSR PULLX
	STX ARG2
	LDX ARG1				AND THEN GO INTO APPLY AGAIN
	JMP APPLY
EVLFNA	LDX ARG1
	LDX 2,X					GET OLD A-LIST
	LDX 2,X
	LDX 0,X
	STX ARG3
	LDX ARG1
	LDX 2,X					GET FUNCTION
	LDX 0,X
	STX ARG1
	JMP APPLY			AND GO INTO APPLY
EVLAMB	LDX ARG1
	JSR PUSHX			POINTER TO LAMBDA-FORM
	LDX 2,X
	LDX 0,X
	STX SAVEX			POINTER TO LAMBDA VARIABLES
	LDX ARG2			ACTUAL PARAMETERS.
	BEQ	VAREXH
PAIRLS	JSR PUSHX			NOW ASSOCIATE LAMBDA-VAR
	LDX 0,X				WITH ACTUALS
	STX ARG2
	LDX SAVEX
	BEQ TA.ER
	LDX 0,X
	STX ARG1			EXTEND A-LIST WITH A
	JSR CONS			VARIABLE-VALUE PAIR.
	STX ARG1
	LDX ARG3
	STX ARG2
	JSR CONS
	STX ARG3			UPDATE A-LIST POINTER.
	LDX SAVEX
	LDX 2,X				NEXT LAMBDA VARIABLE
	STX SAVEX
	JSR PULLX
	LDX 2,X				NEXT ACTUAL PARAMETER
	BNE PAIRLS
VAREXH	LDX	SAVEX			BOTH LISTS EXHAUSTED?
	BNE TLA.ER			NO TOO LITTLE ARGS
	LDX ARG3
	STX ARG2			GET UPDATED A-LIST
	JSR PULLX			GET FUNCTION TO BE EVALUATED
	LDX 2,X				(2ND FORM ON LAMBDA LIST)
	LDX 2,X
	LDX 2,X
	STX ARG1			AND LET EVAL DO THE WORK
	JMP EVAL
TA.ER	LDX #TMA.MS
	INS
	INS
	BRA RECOV1
TLA.ER	LDX #TLA.MS
RECOV1	JSR PMESSG
	LDX #FOR.MS
	JSR PMESG1
	JSR PULLX
	STX ARG1
	JSR PRINTE			PRINT FUNCTION CALL
	JMP LISP
 
* (EVLIS LIST ALIST) 
*
* EVALUATE ALL ELEMENTS 0F 'LIST'
* THE VALUE IS A LIST OF RESULTS
* OF ALL THESE EVALUATIDNS.
*
EVLIS 	LDX ARG1
	BEQ EVLISX			EMPTY SOURCE-LIST RETURNS NIL.
	JSR PUSHX
	LDX 0,X 			GET A FORM PROM SOURCE-LIST
	STX ARG1
	LDX ARG2
	JSR PUSHX
	LDX ARG1
	JSR EVAL			AND EVALUATE THAT FORM
	STX ARG3
	JSR PULLX
	STX ARG2
	JSR PULLX
	LDX 2,X				GET CDR OF SOURCE-LIST
	STX ARG1
	LDX ARG3
	JSR PUSHX
	LDX ARG1
	BSR EVLIS			AND GO INTO EVLIS AGAIN!
	STX ARG2
	JSR PULLX
	STX ARG1
	JSR CONS			CONS THE RESULT TO
EVLISX	RTS					A RESULT-LIST.
*
* (PROG (VAR! VARZ....) LABEL (STATEMENT).......)
*
PROG	LDX PROGB
	JSR PUSHX
	LDX RUNP
	JSR PUSHX
	LDX ARG1
	BEQ RETNIL
	LDX 2,X
	BEQ RETNIL			NO PROG-LIST
	STX PROGB
	LDX ARG2
	STX ARG3			SAVE A-LIST
	LDX ARG1
	LDX 0,X				GET LIST OF PROG VARIABLES
	BEQ PROG1
LOCVAR	JSR PUSHX
	LDX 0,X				APPEND PROG VARIABLES
	STX ARG1			TO THE CURRENT A-LIST
	LDX N				THE ASSOCIATED VALUE
	STX ARG2
	JSR CONS			IS INITIALLY NIL
	STX ARG1
	LDX ARG3
	STX ARG2
	JSR CONS
	STX ARG3			UPDATE A-LIST POINTER
	JSR PULLX
	LDX 2,X
	BNE LOCVAR			NEXT VARIABLE
PROG1	LDX	ARG3
	STX ARG2			UPDATED A-LIST
	LDX PROGB			BEGIN OF PROG
EXPROG	STX RUNP
	LDX 0,X				GET STATEMENT FROM PROG-LIST
	STX ARG1
	JSR ATOM			ATOMIC?
	BNE NXTST			YES, LABEL SO SKIP
	LDX ARG2
	JSR PUSHX
	LDX ARG1
	JSR EVAL			NO,EVALUATE STATEMENT
RETPRG	JSR PULLX
	STX ARG2
NXTST	LDX RUNP
	LDX 2,X				NEXT STATEMENT
	BNE EXPROG
RETNIL	JSR PULLX			RUNNING OUT OF PROGRAM!
	STX RUNP
	JSR PULLX
	STX PROGB
	LDX N				RETURN WITH VALUE NIL
	RTS
*
* (GO X) 
*
* GO TO LABEL X (LITERAL)
*
GO	LDX ARG1
	BEQ GO.ER
	LDX 0,X
	STX ARG1
	LDX PROGB			IN A PROG?
	BEQ GO.ER			NO, ERROR
FNDLBL	STX ARG2			SEARCH FOR A LABEL
	LDX 0,X
	CPX ARG1			MATCH?
	BEQ LABEL			YES
	LDX ARG2
	LDX 2,X				NO, NEXT ELEMENT ON PROG-LIST
	STX ARG2
	BNE FNDLBL
GO.ER	LDX #GO.MS
FATAL1	JSR PMESSG
	LDX ARG1
	JSR PRINTE
	JMP LISP
LABEL	LDAA ARG2			LABEL FOUND.
	LDAB ARG2+1			MODIFY RUNNING POINTER
	STAA RUNP
	STAB RUNP+1
	RTS

*
* (RETURN X)
* RETURN FROM PROG WITH X AS VALUE
*
RETURN	LDX	PROGB			IN A PROG?
	BEQ	RETVAL
CLRSTK	TSX
	INS					YES, CLEAN UP THE STACK
	INS					USED BY PROG.
	LDX 0,X
	CPX #RETPRG
	BNE CLRSTK
	INS
	INS
	JSR PULLX
	STX RUNP
	JSR PULLX
	STX PROGB
RETVAL	LDX ARG1			RETUN EVALUATED ARG OF RETURN
	RTS
*
* GET TWO NUMERIC VALUES
* ON EXIT A&3 CONTAINS THE NUMERIC VALUE OF ARG1
* AND X POINT TO THE NUMERIC VALUE OF ARG2.
* 
GET2N	LDX 0,X
	DEX
	BNE NN.ER			ARG1 NOT A NUMBER
	LDX ARG2
	LDX 0,X
	DEX
	BNE NN.ER2			ARG2 NOT A NUMBER
	LDX ARG1
	LDX 2,X
	LDAA 0,X			GET NUMBERIC VALUE OF ARG1
	LDAB 1,X
	LDX ARG2
	LDX 2,X				POINT TO NUMERIC VALUE OF ARG2
	RTS
NN.ER2	LDX ARG2
	STX ARG1
NN.ER	LDX #NN.MS
	JMP FATAL1
*
* (PLUS X Y)
*
* RESULT IS THE SUM OF x AND Y
*
PLUS 	JSR GET2N
	ADDB 1,X 				16-BIT ADD
	ADCA 0,X
	BVS OV.ER 				OVERFLOW
STRES 	JMP PUTIN 				STORE RESULT
*
* (MINUS X Y)
*
* RESULT IS X - Y
*
MINUS 	BSR GET2N
	SUBB 1,X
	SBCA 0,X 				16-BIT SUBSTRACT
	BVC STRES
OV.ER 	LDX #OV.MS
	PSHA
	PSHB
	JSR PMESSG
	PULB
	PULA
	JMP PUTIN
*
* GET TWO NUMERIC VALUES
* AND MAKE ABSOLUTE
* NUM1:ABS<ARG1)
* NUM2:ABS(ARGZ)
*
G2ABS 	BSR GET2N
	PSHA
	EORA 0,X
	STAA SIGN 				SAVE RESULT SIGN
	PULA 
	BSR ABS
	STAA NUM1
	STAB NUM1+1
	LDAA 0,X
	LDAB 1,X
	BSR ABS
	STAA NUM2
	STAB NUM2+1
	RTS
ABS 	TSTA
	BPL ABS1
NEG 	COMA 					ABSOLUTE VAL OF A & B
	NEGB
	BNE ABS1
	INCA
ABS1	RTS
*
* (TIMES x Y)
* 
* RESULT IS THE PRODUCT 0F X AND Y 
*
TIMES 	BSR G2ABS
	LDX #17 				STEP COUNT
	CLRA
	CLRB
	BRA MUL3
MUL1	BCC MUL2
	ADDB NUM1+1
	ADDA NUM1
MUL2	RORA
	RORB
MUL3	ROR NUM2
	ROR NUM2+1
	DEX
	BNE MUL1
	TSTA
	BNE OV.ER
	TSTB
	BNE OV.ER				TEST FOR OVERFLOW
	LDAA NUM2
	BMI OV.ER
	LDAB NUM2+1
	BRA RSTRS
*
* (QUOTIENT X Y)
*
*  RESULT IS X/Y
*
DIV 	BSR G2ABS
	LDX NUM2
	BEQ OV.ER					DIVISION BY ZERO!
	CLR STEPC
	INC STEPC
DIVSCL	INC STEPC
	ASLB						PRESCALE NUM2
	ROLA
	BPL DIVSCL
	STAA NUM2
	STAB NUM2+1
	LDAA NUM1
	LDAB NUM1+1
	CLR NUM1
	CLR NUM1+1
DIV1	SUBB NUM2+1
	SBCA NUM2
	BCC DIV2
	ADDB NUM2+1
	ADCA NUM2
	CLC
	FCB $9C						SKIP
DIV2	SEC
	ROL NUM1+1					SHIFT INTO RESULT
	ROL NUM1
	LSR NUM2
	ROR NUM2+1
	DEC STEPC
	BNE DIV1
	LDAA NUM1
	LDAB NUM1+1
RSTRS	TST SIGN
	JSR ABS+1
*
* CREATE A NUMERIC ATOM WHOSE VALUE
* IS IN ACCUMULATOR A.
*

PUTIN 	STAA NUM1 				CREATE A NUMERIC ATOM
	STAB NUM1+1 			FOR THE RESULT OF AN
	LDX N
	STX ARG1
	STX ARG2
	JSR CONS
	STX ARG2
	JSR CONS
	STX ARG1
	INC 1,X
	LDX ARG2
	LDAA NUM1
	LDAB NUM1+1
	STAA 0,X
	STAB 1,X
	LDX ARG1
	RTS
SN.MS 	FCC /SYNTAX ERRO/		 	Directive workaround because
	FCB 'R|$80				original code used fcs directive
*						which set sign bit on last character
*						not supported in motorola assembler.
NA.MS 	FCC /NON ATOMIC ARG:/
	FCB $20|$80				ascii space ORd sign bit high
TMA.MS 	FCC /TOO MANY ARGS/
	FCB $20|$80
FN.MS 	FCC /ILL. FUNCTION:/
	FCB $20|$80
AA.MS 	FCC /ATOMIC ARG:/
	FCB $20|$80
IN.MS 	FCC /ILLEGAL NUMBE/
	FCB 'R|$80
GO.MS 	FCC /ILLEGAL GO:/
	FCB $20|$80
NN.MS 	FCC /NON NUMERIC ARG:/
	FCB $20|$80
OV.MS 	FCC /OVERFLO/
	FCB 'W|$80
TLA.MS 	FCC /TOO LITTLE ARGS/
	FCB $20|$80
FOR.MS 	FCC /FOR:/
	FCB $20|$80
FL.MS 	FCC /MEMORY FUL/
	FCB 'L|$80
SO.MS 	FCC /STACK OVERFLO/
	FCB 'W|$80
ID.MS 	FCC /ILLEGAL DEVIC/
	FCB 'E|$80
HED 	FCC /  LISP 1.5  V3A/
	FCB $20|$80
*
* THE OBJECT LIST (OBLIST)
*
LOC	EQU	*+3
	ORG LOC/4*4				EVEN WORD ADDRESSING
NAMNIL	FCC /NI/					PRINT NAME 0F ATOM 'NIL'
	FDB *+2
	FCB 'L,$80	
	FDB NIL
PRPNIL	FDB APVAL,*+4					PROPERTY OF ATOM 'NIL'
	FDB NIL,*+4
	FDB FSUBR,*+4
	FDB FALSE,NIL
OBLIST 	FDB *+12+M,*+4
	FDB APVAL,*+4 
	FDB OBL1,NIL
	FCC /OB/
	FDB *+2
	FCC /LI/ 
	FDB *+2
	FCC /ST/ 
	FDB NIL
OBL1	FDB NIL,*+4
	FDB *+4,0BL2
T	FDB T.PNAM+M,*+4
	FDB APVAL,*+4
	FDB T,*+4
	FDB SUBR,*+4
	FDB EX,NIL
T.PNAM	FCB	'T,F
	FDB NIL
OBL2	EQU	*
	FDB *+4,OBL3
LAMBDA  FDB *+12+M,*+4
	FDB APVAL,*+4
	FDB *-8,NIL
	FCC /LA/
	FDB *+2
	FCC /MB/
	FDB *+2
	FCC /DA/
	FDB NIL
OBL3	EQU *
	FDB *+4,OBL4
APVAL	FDB *+12+M,*+4 
	FDB APVAL,*+4
	FDB *-8,NIL
	FCC /AP/
	FDB *+2
	FCC /VA/
	FDB *+2
	FCB 'L,F
	FDB NIL
OBL4	EQU *
	FDB *+4,OBL5
SUBR	FDB *+12+M,*+4
	FDB APVAL,*+4
	FDB *-8,NIL
	FCC /SU/
	FDB *+2
	FCC /BR/
	FDB NIL
OBL5	EQU *
	FDB *+4,OBL6
FSUBR	FDB *+12+M,*+4
	FDB APVAL,*+4
	FDB *-8,NIL
	FCC /FS/
	FDB *+2
	FCC /UB/
	FDB *+2
	FCB 'R,F
	FDB NIL
OBL6	EQU *
	FDB *+4,OBL7
EXPR	FDB *+12+M,*+4
	FDB APVAL,*+4
	FDB *-8,NIL
	FCC /EX/
	FDB *+2
	FCC /PR/
	FDB NIL
OBL7	EQU *
	FDB *+4,OBL8
FEXPR	FDB *+12+M,*+4
	FDB APVAL,*+4
	FDB *-8,NIL
	FCC /FE/
	FDB *+2
	FCC /XP/
	FDB *+2
	FCB 'R,F
	FDB NIL
OBL8	EQU *
	FDB *+4,OBL90
FUNARG	FDB *+12+M,*+4
	FDB APVAL,*+4
	FDB *+8,NIL
	FCC /FU/
	FDB *+2
	FCC /NA/
	FDB *+2
	FCC /RG/
	FDB NIL
OBL90	EQU *
	FDB *+4,OBL9
	FDB *+12+M,*+4
	FDB SUBR,*+4 
	FDB ATOM,NIL
	FCC /AT/
	FDB *+2 
	FCC /OM/
	FDB NIL
OBL9 	EQU *
	FDB *+4,OBL10
	FDB *+12+M,*+4
	FDB SUBR,*+4
	FDB CAR,NIL
	FCC /CA/
	FDB *+2
	FCB 'R,F
	FDB NIL
OBL10	EQU *
	FDB *+4,OBL11
	FDB *+12+M,*+4
	FDB SUBR,*+4
	FDB CDR,NIL
	FCC /CO/ 
	FDB *+2
	FCC /NS/ 
	FDB NIL 
OBL11	EQU *
	FDB *+4,OBL12
	FDB *+12+M,*+4
	FDB SUBR,*+4
	FDB CONS,NIL
	FCC /CO/
	FDB *+2
	FCC /NS/
	FDB NIL
OBL12	EQU *
	FDB *+4,OBL13
	FDB *+12+M,*+4
	FDB SUBR,*+4
	FDB NULL,NIL
	FCC /NU/
	FDB *+2
	FCC /LL/
	FDB NIL
OBL13 	EQU *
	FDB *+4,OBL14
	FDB *+12+M,*+4
	FDB SUBR,*+4
	FDB EQ,NIL
	FCC /EQ/
	FDB NIL 
OBL14 	EQU *
	FDB *+4,OBL15
	FDB *+12+M,*+4
	FDB SUBR,*+4
	FDB NUMBER,NIL
	FCC /NU/ 
	FDB *+2
	FCC /MB/
	FDB *+2
	FCC /ER/
	FDB NIL
OBL15	EQU *
	FDB *+4,OBL16
	FDB *+12+M,*+4
	FDB SUBR,*+4
	FDB GREATR,NIL
	FCC /GR/
	FDB *+2
	FCC /EA/
	FDB *+2
	FCC /TE/
	FDB *+2
	FCC /RP/
	FDB NIL
OBL16	EQU *
	FDB *+4,OBL17
	FDB *+12+M,*+4
	FDB SUBR,*+4
	FDB READ,NIL
	FCC /RE/
	FDB *+2
	FCC /AD/
	FDB NIL
OBL17	EQU *
	FDB *+4,OBL18
	FDB *+12+M,*+4
	FDB SUBR,*+4
	FDB PRINT,NIL
	FCC /PR/
	FDB *+2
	FCC /IN/
	FDB *+2
	FCB 'T,F
	FDB NIL
OBL18	EQU *
	FDB *+4,OBL19
	FDB *+12+M,*+4
	FDB SUBR,*+4
	FDB PRIN1,NIL
	FCC /PR/
	FDB *+2
	FCC /IN/
	FDB *+2
	FCB '1,F
	FDB NIL
OBL19	EQU *
	FDB *+4,OBL20
	FDB *+12+M,*+4
	FDB SUBR,*+4
	FDB TERPRI,NIL
	FCC /TE/
	FDB *+2
	FCC /RP/
	FDB *+2
	FCC /RI/
	FDB NIL
OBL20	EQU *
	FDB *+4,OBL21
	FDB *+12+M,*+4
	FDB SUBR,*+4
	FDB RPLACA,NIL
	FCC /RP/
	FDB *+2
	FCC /LA/
	FDB *+2
	FCC /CA/
	FDB NIL
OBL21	EQU *
	FDB *+4,OBL22
	FDB *+12+M,*+4
	FDB SUBR,*+4
	FDB RPLACD,NIL
	FCC /RP/
	FDB *+2
	FCC /LA/
	FDB *+2
	FCC /CD/
	FDB NIL
OBL22	EQU *
	FDB *+4,OBL23
	FDB *+12+M,*+4
	FDB SUBR,*+4
	FDB EVAL,NIL
	FCC /EV/
	FDB *+2
	FCC /AL/
	FDB NIL
OBL23	EQU *
	FDB *+4,OBL24
	FDB *+12+M,*+4
	FDB SUBR,*+4
	FDB APPLY,NIL
	FCC /AP/
	FDB *+2
	FCC /PL/
	FDB *+2
	FCB 'Y,F
	FDB NIL
OBL24	EQU *
	FDB *+4,OBL25
	FDB *+12+M,*+4
	FDB SUBR,*+4
	FDB SASSOC,NIL
	FCC /SA/
	FDB *+2
	FCC /SS/
	FDB *+2
	FCC /OC/
	FDB NIL
OBL25	EQU *
	FDB *+4,OBL26
	FDB *+12+M,*+4
	FDB SUBR,*+4
	FDB GET,NIL
	FCC /GE/
	FDB *+2
	FCB 'T,F
	FDB NIL
OBL26	EQU *
	FDB *+4,OBL27
	FDB *+12+M,*+4
	FDB SUBR,*+4
	FDB RETURN,NIL
	FCC /RE/
	FDB *+2
	FCC /TU/
	FDB *+2
	FCC /RN/
	FDB NIL
OBL27	EQU *
	FDB *+4,OBL28
	FDB *+12+M,*+4
	FDB SUBR,*+4
	FDB TEREAD,NIL
	FCC /TE/
	FDB *+2
	FCC /RE/
	FDB *+2
	FCC /AD/
	FDB NIL
OBL28	EQU *
	FDB *+4,OBL29
	FDB *+12+M,*+4
	FDB SUBR,*+4
	FDB PLUS,NIL
	FCC /PL/
	FDB *+2
	FCC /US/
	FDB NIL
OBL29	EQU *
	FDB *+4,OBL30
	FDB *+12+M,*+4
	FDB SUBR,*+4
	FDB MINUS,NIL
	FCC /MI/
	FDB *+2
	FCC /NU/
	FDB *+2
	FCB 'S,F
	FDB NIL
OBL30	EQU *
	FDB *+4,OBL31
	FDB *+12+M,*+4
	FDB SUBR,*+4
	FDB TIMES,NIL
	FCC /TI/
	FDB *+2
	FCC /ME/
	FDB *+2
	FCB 'S,F
	FDB NIL
OBL31	EQU *
	FDB *+4,OBL32
	FDB *+12+M,*+4
	FDB SUBR,*+4
	FDB DIV,NIL
	FCC /QU/
	FDB *+2
	FCC /OT/
	FDB *+2
	FCC /IE/
	FDB *+2
	FCC /NT/
	FDB NIL
OBL32	EQU *
	FDB *+4,OBL33
	FDB *+12+M,*+4
	FDB SUBR,*+4
	FDB READCH,NIL
	FCC /RE/
	FDB *+2
	FCC /AD/
	FDB *+2
	FCC /CH/
	FDB NIL
OBL33	EQU *
	FDB *+4,OBL34
	FDB *+12+M,*+4
	FDB SUBR,*+4
	FDB READ1,NIL
	FCC /RE/
	FDB *+2
	FCC /AD/
	FDB *+2
	FCB '1,F
	FDB NIL
OBL34	EQU *
	FDB *+4,OBL35
	FDB *+12+M,*+4
	FDB SUBR,*+4
	FDB OPEN,NIL
	FCC /OP/
	FDB *+2
	FCC /EN/
	FDB NIL
OBL35	EQU *
	FDB *+4,OBL36
	FDB *+12+M,*+4
	FDB SUBR,*+4
	FDB CLOSE,NIL
	FCC /CL/
	FDB *+2
	FCC /OS/
	FDB *+2
	FCB 'E,F
	FDB NIL
OBL36	EQU *
	FDB *+4,OBL37
	FDB *+12+M,*+4
	FDB SUBR,*+4
	FDB PUTPRP,NIL
	FCC /PU/
	FDB *+2
	FCC /TP/
	FDB *+2
	FCC /RO/
	FDB *+2
	FCB 'P,F
	FDB NIL
OBL37	EQU *
	FDB *+4,OBL40
	FDB *+12+M,*+4
	FDB FSUBR,*+4
	FDB QUOTE,NIL
	FCC /QU/
	FDB *+2
	FCC /OT/
	FDB *+2
	FCB 'E,F
	FDB NIL
OBL40	EQU *
	FDB *+4,OBL41
	FDB *+12+M,*+4
	FDB FSUBR,*+4
	FDB COND,NIL
	FCC /CO/
	FDB *+2
	FCC /ND/
	FDB NIL
OBL41	EQU *
	FDB *+4,OBL42
	FDB *+12+M,*+4
	FDB FSUBR,*+4
	FDB EVLIS,NIL
	FCC /LI/
	FDB *+2
	FCC /ST/
	FDB NIL
OBL42	EQU *
	FDB *+4,OBL43
	FDB *+12+M,*+4
	FDB FSUBR,*+4
	FDB PROG,NIL
	FCC /PR/
	FDB *+2
	FCC /OG/
	FDB NIL
OBL43	EQU *
	FDB *+4,OBL44
	FDB *+12+M,*+4
	FDB FSUBR,*+4
	FDB SETQ,NIL
	FCC /SE/
	FDB *+2
	FCC /TQ/
	FDB NIL
OBL44	EQU *
	FDB *+4,OBL45
	FDB *+12+M,*+4
	FDB FSUBR,*+4
	FDB ALIST,NIL
	FCC /AL/
	FDB *+2
	FCC /IS/
	FDB *+2
	FCB 'T,F
	FDB NIL
OBL45	EQU *
	FDB *+4,OBL46
	FDB *+12+M,*+4
	FDB FSUBR,*+4
	FDB FUNCTI,NIL
	FCC /FU/
	FDB *+2
	FCC /NC/
	FDB *+2
	FCC /TI/
	FDB *+2
	FCC /ON/
	FDB NIL
OBL46	EQU *
	FDB *+4,OBL47
	FDB *+12+M,*+4
	FDB FSUBR,*+4
	FDB GO,NIL
	FCC /GO/
	FDB NIL
OBL47	EQU *
	FDB OBLIST,NIL
LISPSP	EQU *
	END
